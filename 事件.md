<p id="title"><p>
  
# :gem:标题：对象和类

<a href="#a1">:diamonds:事件流</a><br>
<a href="#a2">:diamonds:事件处理程序</a><br>
<a href="#a3">:diamonds:事件对象</a><br>
<a href="#a4">:diamonds:事件类型</a><br>
<a href="#a5">:diamonds:内存和性能</a><br>
<a href="#a6">:diamonds:模拟事件</a><br>
<a href="#a7">:diamonds:小结</a><br>
<p id="a1"></p>

# :bulb:事件流
<a href="#title">:+1:回到目录</a>
事件就是文档和浏览器窗口中发生的一些特定的交互瞬间，可以使用帧听器来预定事件。
<br>事件流描述的是页面中接收事件的顺序
+ IE是事件冒泡流：即事件的开始时由最具体的元素接收，然后逐级向上传播到较为具体的元素，所有的现代浏览器都支持事件冒泡。
+ Netscape Communicator是事件捕获流：不太具体的节点更早接受到事件，再到具体的节点
## :snowflake:事件冒泡
## :snowflake:事件捕获
## :snowflake:事件流
DOM2时间流分为三个阶段：事件捕获阶段，处于目标阶段，和事件冒泡阶段
<p id="a2"></p>

# :bulb:事件处理程序
<a href="#title">:+1:回到目录</a>
事件就是用户或浏览器自身执行的某种动作，诸如click,load,mouseover，都是事件的名字，而响应某个事件的函数叫做事件处理程序（事件侦听器）--以on开头
## :snowflake:HTML事件处理程序
```javascript
<input type="button" value="Click me" onclick="alert('Clicked')">
```
这个值是JavaScript，所以不能使用未经转义的HTML语法，这里使用了单引号，如果想使用双引号，
```javascript
<input type="button" value="Click me" onclick="alert(&qout;Clicked&qout)">
```
也可以调用在页面其他地方定义的脚本
```javascript
<script>
  function showMessage()
  {
    alert("Hello,World");
  }
</script>
<input type="button" value="Click me" onclick="showMessage()">
```
这样指定事件处理程序具有一些独到之处，会创建一个封装着元素属性值的函数，有一个局部变量event(事件对象)
```javascript
<!--输出click-->
<input type="button" value="Click me" onclick="alert(event.type)">
//通过event变量，可以直接访问事件对象，在这个函数的内部，this值等于事件的目标函数

<input type="button" value="Click me" onclick="alert(this.value)">

//关于这个动态创造的函数，他拓展作用域的方式很特别，在这个函数内部，可以像访问局部变量一样访问document及该元素的本身，可以通过with拓展作用域

function() {
  with(document){
    with(this){
      //元素属性值
    }
  }
}
//如果当前元素是一个表单元素，则作用域中还会包含访问表单元素（父元素）的入口：
function(){
  with(document){
    with(this.form){
      with(this){
        //元素属性值
      }
    }
  }
}
```
这样使用拓展作用域，就是想让事件处理程序无需引用表单元素就能访问其他表单字段
```javascript
<form>
  <input type="text" name="username" value="">
  <input type="button" value="Username" onclick="alert(username.value)">
</form>
```
缺点：时差问题，解决办法：
```javascript
<input type="button" value="Username" onclick="try{showMessage();}catch(ex){}">
```
2.这样事件处理程序的作用域链在不同浏览器中会导致不同的结果
## :snowflake:DOM0级事件处理程序
通过JavaScript指定事件的传统方式，就是将一个函数赋值给一个事件处理程序属性。<br>
优点：1.简单2.具有跨浏览器的优势
<br>
使用DOM0级方法制定的事件处理程序被认为是元素的方法，因此这时候的事件处理程序是在元素的作用域中运行，就是程序中的this引用当前的元素
```javscript
var btn = document.getElementById("myBtn");
btn.onclick = function()
{
  alert(this.id);  //myBtn
}


```
也可以删除通过DOM0级方法制定的事件处理程序
```
btn.onclick="null";
```
## :snowflake:DOM2级事件处理程序
"DOM2级事件"定义了两个方法，用于处理指定和删除事件处理程序的操纵：addEventListenenr()和removeEventListener()
<br>
接受3个参数（要处理的事件名，作为事件处理程序的函数，一个布尔值）若为true，表示在捕获阶段调用事件处理程序，false：在冒泡阶段调用事件处理阶段
<br>可以通过下面的方式为事件添加事件处理程序
```javascript
var btn = document.getElementById("myBtn");
btn.addEventListener("click",function(){
  alert("this.id");
},false);
```
DOM2级方法添加事件处理程序的主要好处是可以添加多个事件处理程序。
```javascript
var btn = document.getElementById("myBtn");
btn.addEventListener("click",function(){
  alert("this.id");
},false);
btn.addEventListener("click",function(){
  alert("hello");
},false);
```
按照他们的顺序执行。<br>
通过addEventListener()方法添加的事件处理程序只能通过removeEventListener()来移除；传入的参数必须相同。这样意味着通过addEventListener()添加的匿名函数无法删除。
```javascript
var btn = document.getElementById("myBtn");
btn.addEventListener("click",function(){
  alert("this.id");
},false);

btn.removeEventListenenr("click",function(){
  alert("this.id");
},false);
```
虽然使用了一样的参数，但实际上，第二个参数与传入addEventListener()中的是一个完全不同的函数，改进：
```javascript
var btn = document.getElementById("myBtn");
hander = function(){
alert("this.id");
};
btn.addEventListener("click",handler,false);

btn.removeEventListenenr("click",hander,false);
```
不建议在事件捕获阶段注册事件处理程序
## :snowflake:IE事件处理程序
与DOM类似的方法：attachEvent()和detachEvent():都接受两个参数（程序名称，处理程序函数）
## :snowflake:跨浏览器事件处理程序
<p id="a3"></p>

# :bulb:事件对象
<a href="#title">:+1:回到目录</a>
## :snowflake:DOM中的事件对象
## :snowflake:IE中的事件对象
## :snowflake:跨浏览器的事件对象
<p id="a4"></p>

# :bulb:事件类型
<a href="#title">:+1:回到目录</a>
## :snowflake:UI事件
## :snowflake:焦点事件
## :snowflake:鼠标和滚轮事件
## :snowflake:键盘与文本事件
## :snowflake:复合事件
## :snowflake:变动事件
## :snowflake:HTML5事件
## :snowflake:设备事件
## :snowflake:触摸与手势事件
<p id="a5"></p>

# :bulb:内存和性能
<a href="#title">:+1:回到目录</a>
## :snowflake:事件委托
## :snowflake:移出事件处理程序
<p id="a6"></p>

# :bulb:模拟事件
<a href="#title">:+1:回到目录</a>
## :snowflake:DOM中的事件模拟
## :snowflake:IE中的事件模拟
<p id="a7"></p>

# :bulb:小结
<a href="#title">:+1:回到目录</a>	
