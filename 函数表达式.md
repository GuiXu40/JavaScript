# :sun_with_face:函数表达式
函数声明提示：在执行代码之前会读取函数声明。
<p id="title">:point_down:目录</p>

<a href="#a1">:mag_right:递归</a><br>
<a href="#a2">:mag_right:闭包</a><br>
<a href="#a3">:mag_right:模仿块级作用域</a><br>
<a href="#a4">:mag_right:私有变量</a><br>
---
<p id="a1"></p>

## :ledger:递归
<a href="#title">:telephone_receiver:回到目录</a>
简单的递归函数：阶乘
```javascript
function factorial(num){
  if(num<=1)
  {
    return 1;
  }
  else
  {
    return num*factorial(num-1);
  }
}
```
但在下面的代码中去可以报错
```javascript
  var anotherFactorial=factorial;
  factorial=null;
  alert(anotherFactorial(4));//出错！
```
结果是因为原始函数的引用只剩一个，在一次执行时，已经不再是函数，所以出错<br>
通过使用arguments.caller（是一个指向正在执行的函数的指针）解决这个问题。
```javascript
function factorial(num){
  if(num<=1)
  {
    return 1;
  }
  else
  {
    return num*arguments.caller(num-1);
  }
}
```
在严格条件下会导致错误。<br>
可以使用命名函数表达式来达到相同的效果。
```javascript
var factorial=(function f(num){
  if(num<=1)
  {
    return 1;
  }
  else
  {
    return num*f(num-1);
  }
}

);
```
<p id="a2"></p>

## :ledger:闭包
<a href="#title">:telephone_receiver:回到目录</a>
### :closed_umbrella:闭包与变量
### :closed_umbrella:关于this对象
### :closed_umbrella:内存泄漏
<p id="a3"></p>

## :ledger:模仿块级作用域
<a href="#title">:telephone_receiver:回到目录</a>
<p id="a4"></p>

## :ledger:私有变量
<a href="#title">:telephone_receiver:回到目录</a>
### :closed_umbrella:静态私有变量
### :closed_umbrella:模块模式
### :closed_umbrella:增强的模块模式
